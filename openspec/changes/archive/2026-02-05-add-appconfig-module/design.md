# 应用配置模块设计

## 架构定位
`core/config` 作为核心能力层的配置子模块，负责管理运行时可修改的应用配置，与系统配置（`core/sysconfig`）形成清晰分离：

- **core/sysconfig**：编译时注入、运行时只读、系统级信息（版本、构建时间、ConfigDir）
- **core/config**：运行时加载、用户可修改、应用行为配置（日志级别、语言等）

## 技术选型：为什么选择 viper

### viper 的优势
1. **生态成熟**：Go 社区广泛使用（Kubernetes、Hugo 等知名项目）
2. **功能完备**：支持多格式（YAML/JSON/TOML）、环境变量、配置热重载
3. **接口简洁**：Get/Set 语法简单，支持嵌套配置
4. **零依赖侵入**：不强制特定配置结构，灵活性高

### 备选方案对比
| 方案 | 优势 | 劣势 | 结论 |
|------|------|------|------|
| viper | 生态成熟、功能完备 | 依赖较重（约 1MB） | ✅ 采用 |
| 手写 YAML 解析 | 轻量、可控 | 需实现热重载、合并等功能 | ❌ 成本高 |
| koanf | 更轻量、更模块化 | 生态较小、文档少 | ❌ 生态风险 |

**决策**：采用 viper，优先生态成熟度和开发效率。

## 配置文件路径策略

### 路径组成
```
完整路径 = sysconfig.GetConfigDir() + "/" + sysconfig.GetConfigFile()
```

### 路径解析逻辑
1. **ConfigDir 不为空**：使用 sysconfig 提供的目录
   - 示例：`/etc/daf-app` + `config.yml` → `/etc/daf-app/config.yml`
2. **ConfigDir 为空**：使用当前工作目录
   - 示例：当前目录 + `config.yml` → `./config.yml`
3. **文件不存在**：使用默认值并自动创建配置文件

### 跨平台路径处理
- 使用 `filepath.Join()` 确保路径分隔符正确
- 使用 `filepath.Abs()` 转换为绝对路径（避免相对路径歧义）
- 使用 `os.MkdirAll()` 确保配置目录存在

## 配置分层设计（预留）

本提案实现单层配置（app 配置），但架构预留分层扩展能力：

### 未来分层结构
1. **system 配置**：系统级默认配置（由运维配置，优先级最低）
2. **app 配置**：应用级配置（本提案实现，优先级中等）
3. **user 配置**：用户级配置（用户自定义，优先级最高）

### 合并规则（未来实现）
- 配置按优先级合并：`user > app > system`
- 使用 viper 的 `MergeConfigMap` 功能实现

## 配置项设计

### 日志配置（log）
| 字段 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| log.dir | string | `logs` | 日志目录（相对或绝对路径） |
| log.level | string | `info` | 日志级别（debug/info/warn/error） |

**设计原则**：
- 日志目录支持相对路径（相对于可执行文件）和绝对路径
- 日志级别采用通用标准（debug/info/warn/error），方便后续集成主流日志库

### 国际化配置（i18n）
| 字段 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| i18n.language | string | `zh-CN` | 语言代码（zh-CN/en-US/ja-JP） |

**设计原则**：
- 语言代码采用 BCP 47 标准（如 zh-CN、en-US）
- 默认值为中文，方便国内用户

### 配置扩展性
配置结构使用嵌套设计（log、i18n 等命名空间），方便未来扩展：
- 添加新模块配置（如 plugin.enabled）
- 添加新字段（如 log.max_size）

## 错误处理策略

### 配置文件不存在
- **行为**：使用默认值并自动创建配置文件
- **日志**：INFO 级别记录"配置文件不存在，使用默认值并创建"

### 配置文件格式错误
- **行为**：返回错误，不使用默认值
- **日志**：ERROR 级别记录"配置文件格式错误"
- **用户提示**：返回明确的错误信息（包含行号）

### 配置目录不可写
- **行为**：返回错误，不创建配置文件
- **日志**：ERROR 级别记录"配置目录不可写"
- **用户提示**：返回权限错误信息

## 线程安全与并发

### 本提案范围
- 单线程使用场景（应用启动时加载一次）
- 不实现并发控制

### 未来优化方向
- 添加 `sync.RWMutex` 保护配置读写
- 支持配置热重载时的并发安全

## 测试策略

### 单元测试覆盖
1. **加载测试**：
   - 配置文件存在时正确加载
   - 配置文件不存在时使用默认值
   - 配置文件格式错误时返回错误
2. **保存测试**：
   - 保存配置后可重新加载
   - 配置目录不存在时自动创建
3. **读取测试**：
   - GetLogDir/GetLogLevel/GetLanguage 返回正确值
4. **设置测试**：
   - SetLogDir/SetLogLevel/SetLanguage 正确修改配置

### 集成测试（未来）
- 与 logger 模块集成测试（验证日志配置生效）
- 与 i18n 模块集成测试（验证语言配置生效）

## 文档要求

### 使用文档（docs/appconfig-guide.md）
- 配置文件格式说明
- 配置项含义与默认值
- 使用示例（加载、读取、修改、保存）
- 常见问题（权限、格式错误、路径问题）

### 示例配置（configs/app/config.yml）
- 包含所有配置项及注释
- 使用默认值
- 作为用户参考模板

## 与其他模块的关系

### 依赖关系
```
core/config
  ↓ 依赖
core/sysconfig (获取 ConfigDir、ConfigFile)
```

### 被依赖关系（未来）
```
core/logger → core/config (读取 log.dir、log.level)
core/i18n → core/config (读取 i18n.language)
core/runtime → core/config (应用启动时初始化配置)
```

### 初始化顺序
```
1. sysconfig (编译时注入，无需初始化)
2. config (加载配置文件)
3. logger (使用 config 的日志配置)
4. i18n (使用 config 的语言配置)
5. 其他模块
```

## 未来演进方向

### 短期（下个迭代）
- 配置验证（字段合法性校验）
- 配置热重载（监听文件变化）

### 中期（2-3 个迭代）
- 配置分层（system/app/user）
- 环境变量覆盖（支持 ENV 覆盖配置）

### 长期（商业版）
- 配置加密（敏感字段加密存储）
- 云端配置同步（多设备配置同步）
- 配置审计（记录配置变更历史）
